#!/usr/bin/env python

import functools
from decorator import decorator

from cachedict import CacheDict

#@decorator
def cache(selector):
    """
    Decorator for cache.

    >>> @cache('ram')
    ... def foo(a , b):
    ...     return a + b
    >>> foo(1,2)
    3
    >>> class A(ram):
    ...     @cache('plop')
    ...     def b(self, c, d):
    ...         return c*d
    >>> a = A()
    >>> a.b(2,3)
    
    """


    def _cache(fctn):
        # haxh = cPickle.dumps((args, sorted(kwargs.iteritems())))
        
        # if haxh not in memory:
        #     memory[haxh] = fctn(*args,**kwargs)
            
        #     return memory[haxh]
        # if memo.__doc__:
        #     memo.__doc__ = "\n".join([memo.__doc__,"This function is memoized."])
        @functools.wraps(fctn)
        def __cache(*args, **kwargs):
            print selector
            print "fun :"+str(fctn.__name__)
            tmpArgs =[]

            cd = CacheDict.getInstance()

            if selector in cd:
                c = cd[selector]
                if c.isCached(fctn.__name__, *args, **kwargs):
                    return c.cached(fctn.__name__, *args, **kwargs)
                else:
                    return c.putInCache(fctn.__name__, *args, **kwargs, fctn(*args, **kwargs))
            else :
                return fctn(*args, **kwargs)
        return __cache

    return _cache

if __name__ == "__main__":
    import doctest
    doctest.testmod()
