#!/usr/bin/env path

import hashlib
import os.path

from abstractcache import AbstractCache
from exceptionconfig import *


class FsCache(object):
    """
    Cache on filesytem.
    """

    def __init__(self, config):
       """
       Cache on filesytem.

       >>> f = FsCache({'dir' : 'test/cache'})
       >>> f #doctest: +ELLIPSIS
       <__main__.FsCache object at 0x...>
       >>> f._dir
       'test/cache'
       """ 

       self._dir = config['dir']
       
       
    def isCached(self, func, *args, **kwargs):
        """
        Is in Cache ?
        
        >>> f = FsCache({'dir' : 'test/cache'})
        >>> f.isCached('b',[1, 2], {})
        False
        >>> foo = open('test/cache/455bdde8de3f1b5ddbeac7ba0af07ba23f8b725c', 'wb')
        >>> foo.write('bar')
        >>> foo.close()
        >>> f.isCached('c',[1, 2], {})
        True
        """
        return os.path.isfile(os.path.join(self._dir,
                                           self._computeFilename(func, *args, **kwargs)))

    def cached(self, func, *args, **kwargs):
        """
        Return cache result.
        
        >>> f = FsCache({'dir' : 'test/cache'})
        >>> foo = open('test/cache/455bdde8de3f1b5ddbeac7ba0af07ba23f8b725c', 'wb')
        >>> foo.write('bar')
        >>> foo.close()
        >>> f.cached('c',[1, 2], {})
        'bar'
        """
        cachedFile = open(os.path.join(self._dir,
                                       self._computeFilename(func, *args, **kwargs)),'rb')
        tmp = cachedFile.read()
        cachedFile.close()
        return tmp
    

    def putInCache(self, func, result, *args, **kwargs):
        """
        Put file in cache.

        >>> f = FsCache({'dir' : 'test/cache'})
        >>> f.putInCache('a', 3, [1, 2], {})
        3
        >>> os.path.isfile('test/cache/b546706c3d1155e7fbd95e03f25ae7695590d1d0')
        True
        """
        filename = self._computeFilename(func, *args, **kwargs)
        cacheFile = open(os.path.join(self._dir, filename), 'wb')
        cacheFile.write(str(result))
        cacheFile.close()
        return result

    def _computeFilename(self, func, *args, **kwargs):
        """
        Compute sha1 hash for filename.

        >>> f = FsCache({'dir' : 'test/cache'})
        >>> f._computeFilename('a',[1, 2], {})
        'b546706c3d1155e7fbd95e03f25ae7695590d1d0'
        """
        s = hashlib.sha1()
        s.update(str(func))
        s.update(str(args))
        s.update(str(kwargs))

        return s.hexdigest()
    
    @staticmethod
    def checkConf(config):
        """
        Check configuration for fake Cache.

        >>> FsCache.checkConf({})
        Traceback (most recent call last):
        ...
        IncoherentSectionConfig: not module FsCache
        >>> FsCache.checkConf({'module' : 'false'})
        Traceback (most recent call last):
        ...
        IncoherentSectionConfig: not module FsCache
        >>> FsCache.checkConf({'module' : 'FsCache'})
        Traceback (most recent call last):
        ...
        MissingConfigException: no dir in config
        >>> FsCache.checkConf({'module': 'FsCache', 'dir': 'test/noexist'})
        Traceback (most recent call last):
        ...
        CacheDirIncorrect: test/noexist isn't correct
        >>> FsCache.checkConf({'module': 'FsCache', 'dir': 'test/cache'})
        """
        try:
            if config['module'] == 'FsCache':
                if 'dir' in config:
                    if not os.path.isdir(config['dir']):
                        raise CacheDirIncorrect(config['dir']+ " isn't correct")
                else:
                    raise MissingConfigException('no dir in config')
            else:
                raise IncoherentSectionConfig('not module FsCache')
        except KeyError:
            raise IncoherentSectionConfig('not module FsCache')

class CacheDirIncorrect(Exception):
    """
    >>> CacheDirIncorrect('foo')
    CacheDirIncorrect('foo',)
    """
    pass

if __name__ == "__main__":
    import doctest
    doctest.testmod()
